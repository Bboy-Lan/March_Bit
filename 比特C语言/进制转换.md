



[TOC]

# 一 、进制、编程语言的出现

*首先我们为什么要学进制？以及进制是什么？*

计算机进制是入门知识,也是必须了解的知识。相信大多数人就算不知道具体是什么 也多少听说过二进制，至于具体是什么，或许不知道，但就是在脑子里有印象/doge

首先，我们需要知道，计算机并不真是无比智能到你说啥它干啥，不然还要程序员干啥，它只听程序员的，换个说法就是，程序员能让它听他的，@_@ 晕不晕，说到底也就是程序员掌握有与计算机交汇的语言，也就是常说的编程语言、汇编语言、二进制语言等，程序员就是通过掌握这些语言对计算机发送指令设计程序，让计算机实现一系列操作。

这里很令人好奇，为什么计算机能识得这些语言，程序员写的天马行空的看不清的代码，能实现那么多不可思议的功能，什么智能手机，人工智能等电子产品令人觉得匪夷所思...

> > 为什么计算机会那么聪明？
>
> > *我们知道计算机只是机器也就是铁疙瘩，并不是有思想的人类，计算机的电路中所包含的信息都是来自电信号，而且为了方便地区分输出的是高电压和低电压，早期的操作人员通过带有孔的纸带将程序输入电脑进行编译（对纸条打点），点代表1、0，即它其实只能通过电流识别0、1，而二进制就是这样由来的，**因此0、1二进制是计算机的最基本单元***，*然后计算机科学家就通过这些编码赋予了一定意义，这样最早的二进制语言就实现了，*随后 随着计算机的逐步应用开发，人们意识到 纯粹的0、1编码，多而繁琐 根本不可能完成什么重大的任务，后面出现了汇编语言，操作人员每人一个小册子（指令小册子），虽然这样相比之前好得多但开发人员也是非常非常辛苦。因此计算机的发展迫切需要更加全面便捷的语言，也就是最初的A语言、B语言 发展至今 C语言、JAVA、C++、Python...* 等功能各异,有各自擅长的领域



# 二、内存基本知识

> 在讲进制方面的知识前，必须得提一下计算机内存，从之前的学习我们知道，我们讲解各种数据类型的变量时用**sizeof( ）**操作符求了一下空间大小，由此可见，每个变量都占有一定的内存空间，我们这里所说的内存到底指的是什么？是不是生活中和买电脑时的8G、16G、32G内存有相应的关联呢？

内存是计算机的运行空间，计算机里面的所有计算都依赖内存进行，内存按运行速率有 硬盘、内存、缓冲区等等 下面寄存器处会详细讲

在我们生活中 地球就相当于一个大的内存体 存储着所有的人类 人类被分布在每个国家 我们可以通过这个国家划分的 省市县镇村等具体到找到每家每户 并且每个人都有独特的身份证号码编号，同理 计算机会将自己的内存划分成这么多细小的单元 我们知道计算机还要进行各种复杂的运算 因此它对每一个单元进行编号 编号后还要进行使用 因而它有效的空间就会显得相形见绌  所以它**必须进行更高效的内存管理机制**，当我们需要的时候==（比如定义变量）== 它会随机租借给该变量一个内存单元--我们知道变量的大小单位是byte， 而当使用完成之后这个变量就会自动销毁，重新释放分配给它的内存空间给其他需要空间的地方使用，***而这就是变量 的 可行域生命周期的由来***



```c
printf("%d\n",sizeof(short));// 2 byte
printf("%d\n",sizeof(char));// 1 byte
printf("%d\n",sizeof(int));// 4 byte
printf("%d\n",sizeof(long));// 4 byte
printf("%d\n",sizeof(long long));// 4 or 8 byte
printf("%d\n",sizeof(float));// 4 byte
printf("%d\n",sizeof(double));// 8 byte
```



------



## 1. **内存机理**

*下面我们讨论下*   **计算机所分配的找到某个数值的编号是多少？以及为什么数据类型定义的基本单位是 byte******而不是更细小的bit**，并且细化一下相关的运行机制**

> 这里将计算机内存里面分配的空间编上号 相当于每个人的身份证号码，这样能快速找到对应的值，这些空间我们称之为**地址**，而地址是怎么产生以及表示的呢？



1. **地址的产生**

*计算机有32、64位两种操作系统，以32位为例，32位的系统里面  有32根由 0/1构成的地址线，上面也有解释到  计算机将电信号转换成数字信号0、1这是我们与计算机交流的根本，32个序列由32个不同的 0/1排列构成一个特定的数---一般用十、十六进制来表示(==需要了解下面进制的转换==)*

<img src="C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210614111111688.png" alt="image-20210614111111688" style="zoom:80%;" />

运用高中知识 0/1两种情况 32个序列 共有 2^32^种情况  而每个小格子都有一个特定的地址，因此小格子也就是我们上面提到的地址就有2^32^个，现在我们需要知道每个格子占用了多少的内存空间：



2. **地址的空间占用**

   我们需要讨论一下每个格子占用了多少空间，这里我们假设 2^32^格子它每个格子占用了 1个bit 也就是

   >  2^32^ 个bit 位
   > 根据 下面图中基本单位之间的换算  利用计算器

计算机里面的基本单位及其换算 如下所示：

![img](https://img-blog.csdnimg.cn/2021060620223659.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1Mjg1NTc1,size_16,color_FFFFFF,t_70)

我们根据单位转换计算所得，如果以bit作为每个地址的基本单位，那我们最终得到的只有0.5G的使用内存

>1. 若选用 bit 作单位 那我们知道 一个 char 就需要用掉8个格子  int 需要用掉 32个格子  极大地造成了浪费 不合常理
>2. 、0.5G的 空间 远无法完成所需 

<img src="C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210614114120361.png" alt="image-20210614114120361" style="zoom:80%;" />

我们通过计算得出bit作为基本单位是有问题的，那如果我们换成byte作为基本单位，那在bit的基础上 乘 8 则，我们可用的 约 4GB的内存

> 1. 如果我们换成byte作为基本单位，char 只需要1个格子就行  int  也只需要 4个格子
> 2.  能使用4G空间 满足基本所需



而至于更大的单位的话  char 就只需要  XX分之一个格子就行，格子是独有的 不是共有的 这样会造成紊乱 不符实际



3. **地址的表示方法**

   > 地址的表示方法，地址我们常用的 表示它的编号最常用的的方法就是它 2 进制序列对应的 十六进制数字  即  2进制转0/1序列到 10 进制转到16进制形如 0x00AFFC94，**而16进制是二进制的简写形式 我们知道 一个int变量都有32个序列 那样写出来只会让人眼花缭乱 因此规定了16进制表示法  1个 十六进制数 = 4个二进制序列 因此写32个数 只需要写8个 极大地进行了简化**  所以这里只是表达方式不一样罢了  我们可以通过这些地址准确找到我们需要找到的量
   >
   > 而我们知道  既然int 之类的需要四个格子 每个格子都有编号  ，故而规定了以开头的（小的）为它存储的地址  

这里在后面十六进制里面会举例证明

------



## 2. **寄存器**



寄存器是类似于内存一样的空间  与之类似的有  **网盘 硬盘 内存  高速缓冲区 寄存器**  它们的存储空间依次减少 但是运行效率越来越快，而运行效率是由CPU中央处理器运行的速度决定的的，早期的时候数据存储在内存里面，CPU在内存里面拿数据进行运算，两者的速度差不了太多，随着计算机的发展 CPU的运行效率变得越来越快 以至于内存已经满足不了计算机，因此规定了 运行速率更快但内存含量更低的 高速缓冲区和寄存器（造价更高），每次只需要将其他地方的数据推送到寄存器 保证每时CPU都能在寄存器里面拿到数据进行运算，这样下来整体的效率就提了上来，它们之间基本关系如图所示：

![image-20210616163937797](C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210616163937797.png)







------



# 三、常见的进制



> 通过上面我们了解到，二进制的重要性，从某一方面上讲，二进制构成了整个计算机体系，我们平时生活学习使用的数字都是十进制 不信你想想任何数都能由0-9构成注意不是0-10，因此平时基本看不到 0、1序列的表示，也就是说在计算机里面也对应有相应的转换规则，通过这些转换规则将0、1序列转换成使我们能够理解的，即转换成字符的形式

下面我们来看一张表：

<img src="C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210609174355869.png" style="zoom:80%;" />

可以看见 我们平时看见的字符，一些符号、字母 在计算机里面都规定了各自的十进制数字，从而计算机只需要将这些十进制转化成对应字符就能够让人读懂，我们键盘上的字符也是对应的ASCII 码表，比如 这里打印 字母A

```c
printf("%c",65); //%c 打印字符的意思 ANCII码里面全都是字符及其对应的10进制数字
```

*这里我们介绍一下 常见的进制* 以及它们之间的相互转换

|  **二进制**  |  **十进制**  |
| :----------: | :----------: |
| **相互转换** | **十六进制** |



>进制转换就是进制之间相互转化，计算机就是通过进制的转换过程变得让人们易于理解和编程
>
>我们平时有时候接触进制的时候总是迷迷糊糊的也不知道人怎么 一会  2^n^、一会儿 16^n 到底怎么回事，现在就来详细讲讲 它们间的转换



## 1. **十进制**

**十进制：** *由 0~9的数字组成 生活中所使用的阿拉伯数字 就是 由0~9构成的，其中 逢10进位  10^n^为权  基数为 10*

通过这个例子能直观的看出权 和基数的含义是什么

> （23678）~10~ = 2×10^4^+ 3×10^3^+ 6×10^2^+ 7×10^1^+ 8×10^0^    =  23678      

<u>我们这里肯定会疑问   各自基数上的次方数是怎么得到的？并且最终结果是 所有权的累加值</u>

![image-20210616093305098](C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210616093305098.png)

##  2. **二进制**

**二进制：***刚刚提过二进制就是最基本的 0/1 序列    由  0/1组成 逢2进位 2^n^ 为权 基数是2*

> 1 = 1 × 2^0^              10 = 1 × 2^1^            -----注意 这里 是 0/1序列  不是 生活中的 10 100 100...
>
> 100 = 1 × 2^2^          1000 = 1 × 2^3^
>
> (1111)~2~ = 1 × 2^3^ + 1 × 2^2^ +1 × 2^1^ +1 × 2^0^  = (115)~10~



## 3. **十六进制**

**十六进制：** *由 0 ~ 9 A BＣＤＥＦ　共十五位字符表示　１～15　逢16进位*　16^n^为权　基数16　 

==十六进制是二进制的简写 方便专业的人员进行书写进制数据，其中十六进制的1位数 等于 二进制的 4位数==

>1 = 1 × 16^0^              10 = 1 × 16^1^                    这里为 0的部分直接省略没写的
>
>100 = 1 × 16^2^              1000 = 1 × 16^3^
>
>(5E)~16~ = 5 × 16^1^  + 1 4× 16 ^0^    =  (94)~10~            这里 E = 14  



也许在我们学习过程中你会发现 程序调试起来后  内存窗口出现的 那些个好像就是这样 字母数字的 我们来看看，结合之前所讲到的内存知识

![](C:\Users\Bboy_lan\Pictures\Camera Roll\3.jpg)

```c
//我们再详细分析下 讲过的内存机理

int a = 10;
//这里向内存申请一个4byte空间 内存随机分配 所以可能下次运行出现的结果又是不一样的
printf("%p\n",&a);
// %p 是地址的表示方法  这里我们看看 变量a的地址
```

分析下图：

![](C:\Users\Bboy_lan\Pictures\Camera Roll\5.jpg)



- *我们看到系统中内存存在形式是更为简便的十六进制表示方法*
-  *图示 int 定义的 a 是四个字节的 取地址偏偏取了 0a  D8 后面 00 00 00 的部分分别是 D9 DA DB 因此知道 取地址的时候默认的由低到高，取最低的作为地址 其他可以往上加得到*
- *得到的地址可能是变化的 由于内存随机分配的缘故*





**十六进制与二进制之间的转换** 无非就遵循上面高亮部分的规则 1个十六进制的数 等于 4个二进制序列 我们只需要将十六进制对应的每个数字转换为对应的4个二进制序列就行

>(41)~16~ = 4 × 16^1^ + 1 × 16^0^  = (65)~10~
>
>(41)~16~ = ( 0100   0001 )~2~
>
>(1101 0110)~2~ = (13    6)~16~ =(D6)~10~



学到这里上面ASCII表的基本运作机理 你应该已经了然于胸  无非就是规定一些字符（普通人能直观看懂的符号）然后每个字符都对应相应的 10进制数字   然后 计算机只需要将这些10进制数字转换成2进制数字 就能完成与计算机之间的基本交互，而10进制到2进制的转换我们初学做个了解就行



------



##4. **高进制到低进制之间的转换**

前面我们已近熟悉过了 各个进制到 10进制之间的转换  —— 各自权的和

*而由高进制  10/16 到 2 进制之间  转换 我们只需要 **除以相应的 基数  取余数 当商0时不再除基数 然后所有余数进行倒序排列**就是对应转换后的数*

>(13)~10~ =(?)~2~
>
>13 除 2  商  6 余 1
>
>6  除 2   商 3 余  0
>
>3 除 2    商  1  余  1
>
>1 除  2   商   0  余   1  （出现 分数  不够除的时候就结束了）
>
>然后倒序排列   (1101)~2~  

用图来表示就是 

<img src="C:\Users\Bboy_lan\AppData\Roaming\Typora\typora-user-images\image-20210616103510518.png" alt="image-20210616103510518" style="zoom:80%;" />



16 进制与 2进制之间 转换就不用说了  刚才已说过 两者只是不同的表示形式 

==作为了解这个知识只需要熟练掌握 10进制转化成2进制的数==

------



# 四、常见内存操作



## 1. **原码、补码、反码**

- *整数在计算机里面有原码、反码、补码三种存储方式*
- *整数是以二进制的形式存储的（从上面介绍就可以知道）*
- *有符号的整数二进制得最高位   0 表示正数   1表示负数*

计算机里面规定了  

> **正数的源码 补码 反码都是一样的** 

我们在分析一个变量的二进制序列时 要注意看它的类型 不同的类型得到的 bit 位是不同的 比如下面以int举例

```c
int a = 1;//类型 int  4字节 = 32 bit
// 源码 00000000 00000000 00000000 00000000
//反码  00000000 00000000 00000000 00000000
//补码  00000000 00000000 00000000 00000000
```



> **负数的 原码 反码 补码 需要计算得到**

```c
int a = -1;
//源码 10000000 00000000 00000000 00000001   最高位是1表示负数
//反码 11111111 11111111 11111111 11111110   原码符号位不变 其他位按位取反得到反码
//补码 11111111 11111111 11111111 11111111   反码二进制序列 +1 得到补码

```

==**计算机里面存储整数时存储的是补码，计算时也用的是补码**==

------

## 2 . **移位、取反操作符**

接C语言基础串讲里面的操作符内容--移位及取反操作符

[C语言基础串讲]: https://blog.csdn.net/qq_55285575/article/details/117618476	"2.2 初识操作符"



*注意：这里所有的按位 都是指按二进制位*  *最好将上面的二进制转换的知识跟着算一遍会更加轻松*

- **位操作符****（ **&   |   ^**）** 



**按位与  &**

```c
//按位与  &

int a = 3;//32 个bit位
//00000000 00000000 00000000 00000011
int b = 5;
//00000000 00000000 00000000 00000101
int c = a & b;
//按位与 指的是 两个变量对应的二进制位 只要有一个为0 就为0
//00000000 00000000 00000000 00000001

printf("%d\n",c);//  1

```



**按位或 |**

```c
//按位或  |

int a = 3;
//00000000 00000000 00000000 00000011
int b = 5;
//00000000 00000000 00000000 00000101
int c = a | b;
//按位或 指的是 两个变量对应的二进制位 两个为0 才为0  有一个1就是1
//00000000 00000000 00000000 00000111

printf("%d\n",c);//  1

```



**按位异或   ^**

```c
//按位异或 ^

int a = 3;//32 个bit位
//00000000 00000000 00000000 00000011
int b = 5;
//00000000 00000000 00000000 00000101
int c = a ^ b;
//按位与 指的是 两个变量对应的二进制位 相同为0 相异则为1
//00000000 00000000 00000000 00000110

printf("%d\n",c);//  6
```



- **左移操作符（右移的原理一样 向右移动 空缺的部分用0补位**）



```c
//左移操作符 <<  

int a = 1;
// 00000000 00000000 00000000 00000001            1
int b = a<<1;
//左移操作符这里 将 a 的 二进制序列 向左移位相应位数 然后空缺的部分用0补上
// 00000000 00000000 00000000 00000010            2

int b = a<<2;
// 00000000 00000000 00000000 00000100            4

printf("%d\n",b);


```



- **取反操作符**

```c
// 取反操作符  ~   结合上面原码反码补码分析

int a = 0;
// 00000000 00000000 00000000 00000000  原码

int b = ~a;// ~ 将内存里面的二进制序列也就是补码按位取反 这里0是正数 都一样 然后取反过后 需要逆回去得到原码

// 11111111 11111111 11111111 11111111  补码  
// 11111111 11111111 11111111 11111110  补码-1 = 反码  
// 10000000 00000000 00000000 00000001  原码 反码符号位不变 其他位按位取反

printf("%d\n",b); // -1

```





------



# 五、总结归纳

通过上面的例子我们可以了解到 基本的 进制之间的转换 2-10-16  而较为难见到的 8进制之类的就不做论述



- 我们只需要了解介绍的基本的 换算  二进制 十进制  十六进制之间的 转换就足够了

  





